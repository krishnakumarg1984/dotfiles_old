" vim:ft=vim:norl:
" download vim-plug if not exists

if has('nvim')
    if empty(glob('~/.local/share/nvim/site/autoload/plug.vim'))
        silent !curl -fLo ~/.local/share/nvim/site/autoload/plug.vim --create-dirs
                    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
        augroup vimplug
            autocmd!
            autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
        augroup END
    endif
else
    if empty(glob('~/.vim/autoload/plug.vim'))
        silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
                    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
        augroup vimplug
            autocmd!
            autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
        augroup END
    endif
endif


set noexrc                 "don't source ~/.exrc (vi/vim shared config)
filetype plugin indent on
if !has('g:syntax_on')|syntax enable|endif
set history=100            "make history remember 100 :-commands and searches
set keywordprg=:help
set copyindent          " copy the previous indentation on autoindenting
" set thesaurus+=~/dotfiles/mthesaur.txt

if has('nvim')
else
	packadd! matchit
endif

colorscheme gruvbox
set tags=tags;/

" Turns off physical line wrapping (ie: automatic insertion of newlines)
set textwidth=0
set wrapmargin=0

" colorscheme onehalfdark

" function! ToggleBG()
"     let s:tbg = &background
"     " Inversion
"     if s:tbg == "dark"
"         set background=light
"     else
"         set background=dark
"     endif
" endfunction

" noremap <leader>bg :call ToggleBG()<CR>
set background=dark

" set path+=**                     "Find will start working (under the current directory)
set path=.,./**,,
set suffixesadd=.py,.m,.mat,.gv,.tex      "Find will work harder for these filetypes

" set noshowmatch                " when on a [{(, highlight the matching )}]
" set cpoptions-=m               " ? Highlight when CursorMoved
set cpoptions+=d
set cpoptions+=d
set matchpairs+=<:>            " Highlight <>
" When a bracket is inserted, briefly jump to the matching one.
set showmatch
" Tenths of a second to show the matching paren, when 'showmatch' is set.
set matchtime=1
let g:matchparen_timeout = 20
let g:matchparen_insert_timeout = 20

if has('mouse')
    set mouse=a
endif"

set dictionary+=/usr/share/dict/words

set mousehide

set number
set relativenumber
function! NumberToggle()
    if(&relativenumber == 1)
        set norelativenumber
    else
        set relativenumber
    endif
endfunc
nnoremap <silent> <leader>n :call NumberToggle()<cr>
autocmd InsertEnter * :set norelativenumber
autocmd InsertLeave * :set relativenumber

" Vim needs a more POSIX compatible shell than fish for certain functionality
" to work, such as :%!, compressed help pages and many third-party addons.  If
" you use fish as your login shell or launch Vim from fish, you need to set
" shell to something else in your ~/.vimrc.
" Seriously... god dammit Vim.
if &shell =~# 'fish$'
    set shell=sh
endif

" Only show cursorline in the current window and in normal mode.
augroup cline
    autocmd!

    autocmd WinLeave,InsertEnter * set nocursorline
    autocmd WinEnter,InsertLeave * set cursorline
augroup END


" " On save strip trailing whitespace and convert line endings to Unix format
" " http://stackoverflow.com/questions/356126/how-can-you-automatically-remove-trailing-whitespace-in-vim
" augroup prewrites
"     autocmd!

"     autocmd BufWritePre,FileWritePre * :%s/\s\+$//e | %s/\r$//e
" augroup END

" Don't try to highlight lines longer than 1000 characters
set synmaxcol=300   "Boost performance in rendering long lines

" Make ESC respond faster Lower the delay of escaping out of other modes " keycode times out fast, mapping times out in a bit more time
set timeout       " time out on mappings and keycodes (stronger of the two conditions)
set timeoutlen=500
set ttimeoutlen=0 " A non-negative number here will make the delay to be timeoutlen

" Show @@@ in the last line if it is truncated.
set spelllang=en_gb
syntax spell toplevel

" persistent undo
set undofile
set undodir=$HOME/.vimundo
set undolevels=1000
set undoreload=10000

" Increment alpha strings with vim
" https://blog.mozilla.org/jv/2011/01/12/incrementing-alpha-strings-with-vim/
set nf=octal,hex,alpha


set visualbell               " Use visual bell instead of beeping
set t_vb=                    " But don't want any beep or flash
set noerrorbells
set belloff=all

set encoding=utf-8 nobomb           " Default encoding for saving and reading file
set fileencoding=utf-8     "set file encoding
scriptencoding utfs8
set termencoding=utf-8

" set iskeyword-=.                    " '.' is an end of word designator
" set iskeyword-=#                    " '#' is an end of word designator
" set iskeyword-=-                    " '-' is an end of word designator
" set iskeyword-=!                    " '!' is an end of word designator
" set iskeyword+=@-@

" set autochdir
" Write the contents of the file, if it has been modified, on each
" :next, :rewind, :last, :first, :previous, :stop, :suspend, :tag, :!,
" :make, CTRL-] and CTRL-^ command; and when a :buffer, CTRL-O, CTRL-I,
" '{A-Z0-9}, or `{A-Z0-9} command takes one to another file.
set autowrite


set autoread                        " Autoread when a file is changed from outside

" set viewoptions=cursor,folds,options,cursor,unix,slash " Better Unix / Windows compatibility
set viewoptions=cursor,folds,slash,unix

set fileformat=unix          " Default fileformat
set fileformats=unix,dos,mac

if exists('&inccommand')
    set inccommand=split
endif

set incsearch

set virtualedit=block,insert        " Enable virtualedit in visual block and insert modes
" set virtualedit=onemore                       " Allow the cursor to go
set viminfo='1000,f1,<500

set hidden      " Allow switching buffers without saving current buffer with changes

set ignorecase  " Ignore case search for normal letters
set infercase   " Ignore case on insert completion
set smartcase   " Do case-sensitive search if pattern contains upper case letters


" set tabstop=4 shiftwidth=4
" set softtabstop=4
" set expandtab   " Expand tab to space

set shiftround  " Round indent by shiftwidth

set foldenable
set foldnestmax=5
set foldlevelstart=20
" specifies for which commands a fold will be opened
set foldopen=block,hor,insert,jump,mark,percent,quickfix,search,tag,undo
" set highlight+=N:DiffText

" nnoremap <silent> zr zr:<c-u>setlocal foldlevel?<CR>
" nnoremap <silent> zm zm:<c-u>setlocal foldlevel?<CR>

" nnoremap <silent> zR zR:<c-u>setlocal foldlevel?<CR>
" nnoremap <silent> zM zM:<c-u>setlocal foldlevel?<CR>

" " Change Option Folds
" nnoremap zi  :<c-u>call <SID>ToggleFoldcolumn(1)<CR>
" nnoremap coz :<c-u>call <SID>ToggleFoldcolumn(0)<CR>
" nmap     cof coz

" function! s:ToggleFoldcolumn(fold)
"   if &foldcolumn
"     let w:foldcolumn = &foldcolumn
"     silent setlocal foldcolumn=0
"     if a:fold | silent setlocal nofoldenable | endif
"   else
"       if exists('w:foldcolumn') && (w:foldcolumn!=0)
"         silent let &l:foldcolumn=w:foldcolumn
"       else
"         silent setlocal foldcolumn=4
"       endif
"       if a:fold | silent setlocal foldenable | endif
"   endif
"   setlocal foldcolumn?
" endfunction


" Turn off swapfile
set backup
set backupcopy=yes  " see :help crontab " make a copy of the file and overwrite the original one
set noswapfile
set backupext=.bak

" Only shown when not in insert mode so I don't go insane.
augroup trailing
    autocmd!

    autocmd InsertEnter * :set listchars-=tab:‚ñ∏\ ,eol:¬¨,extends:‚ùØ,precedes:‚ùÆ
    autocmd InsertLeave * :set listchars+=tab:‚ñ∏\ ,eol:¬¨,extends:‚ùØ,precedes:‚ùÆ
    " Use the same symbols as TextMate for tabstops and EOLs
augroup END

if has('conceal')
    set listchars+=conceal:^
    set conceallevel=1 concealcursor=i
endif


" Shortcut to rapidly toggle set list
" nnoremap <leader>a :set list!<CR>

hi link HelpBar Normal
hi link HelpStar Normal

" Wrap conditions
set whichwrap+=h,l,<,>,[,],b,s,~
set nowrap

if has('linebreak')
    set linebreak               " Wrap lines at convenient point (only affects the on-screen display, not actual content in file)
    let &showbreak='‚Ü™ '
    set breakat=\ \ ;:,!?
    if exists('+breakindent')
        set breakindent
    endif
endif

" Highlight searches
set hlsearch
" remove search highlight
nnoremap <leader><space> :nohlsearch<CR>

set cmdheight=2                 " Height of command-line (easy-readable)

" Completion settings in insert mode
set completeopt=longest,menuone,noselect,preview
set complete=.,w,b,u,t,i,kspell ". till i is the default. . = current buffer. w  = any other windows, b = any other buffers opened, u = unopened buffers, t = tags, i = current and included files
"kspell = k means also look in the dictionary, kspell is the same, but only look up when spell-check is enabled

set pumheight=15                " Set popup menu max height

set wildmenu
set wildchar=<TAB> " Character for CLI expansion (TAB-completion)
set wildmode=list:longest,full
" Ignore the following stuff when tab completing
set wildignore+=.hg,.git,.svn,*.o,*.obj,*.pyc,*.luac,*.jpg,*.jpeg,*.png,*.gif,*.bmp,*.pdf,*.class,*.dmg,*.DS_Store,*.lnk,*.ini,*.dats

set wildignore=.git,*.pyc,*.o,*.a,*.swp,*.dll,*.obj,*.bak,*.exe,*.jpg,*.gif,*.png

" Disable output and VCS files
set wildignore+=*.o,*.out,*.obj,.git,*.rbc,*.rbo,*.class,.svn,*.gem

" Disable archive files
set wildignore+=*.zip,*.tar.gz,*.tar.bz2,*.rar,*.tar.xz

" Ignore bundler and sass cache
set wildignore+=*/vendor/gems/*,*/vendor/cache/*,*/.bundle/*,*/.sass-cache/*

" Ignore rails temporary asset caches
set wildignore+=*/tmp/cache/assets/*/sprockets/*,*/tmp/cache/assets/*/sass/*

" Ignore build dir
set wildignore+=build/*,media/*

" Ignore node modules
set wildignore+=node_modules/*,bower_components/*

" Disable temp and backup files
set wildignore+=*.swp,*~,._*
set wildignore+=.hg,.git,.svn,*.o,*.obj,*.pyc,*.luac,*.jpg,*.jpeg,*.png,*.gif,*.bmp,*.pdf,*.class,*.dmg,*.DS_Store,*.lnk,*.ini,*.dats

set wildignore+=types_*taghl,tags

"Adjust window size of preview and help
set previewheight=8
set helpheight=12
set ttyfast

set nostartofline               " The cursor is kept in the same column (if possible)
set backspace=indent,eol,start

set splitbelow                  " Splitting a window will put the new window below the current one
set splitright                  " Splitting a window will put the new windowright the current one

set showmode                    " Display the current mode

" Set's comments to italics
" Reference: https://www.reddit.com/r/vim/comments/24g8r8/italics_in_terminal_vim_and_tmux/
" I realize setting t_ZH and t_ZR directly is probably 'bad' to more advanced
" vim folks.  Practicality beats purity. ¬Ø\_(„ÉÑ)_/¬Ø
set t_ZH=[3m
set t_ZR=[23m
highlight clear SignColumn      " SignColumn should match background,SignColumn column where |signs| are displayed
highlight Comment cterm=italic


if has('cmdline_info')
    set ruler                   " Show the ruler
    set rulerformat=%30(%=\:b%n%y%m%r%w\ %l,%c%V\ %P%)
    set showcmd
endif

if has('statusline')
    set laststatus=2 "Always show a status line
    set statusline=%F%m%r%h%w[%L][%{&ff}]%y%=[%p%%][%04l,%04v]
    " filepath | modified flag | read only flag | help flag | preview flag |
    " number of lines | current ft | current syntax | % into file | line, column
    " set statusline=%<%f\
    " set statusline+=%w%h%m%r
    " set statusline+=\ [%{&ff}/%Y]
    " set statusline+=\ [%{getcwd()}]
    " set statusline+=%=%-14.(%l,%c%V%)\ %p%%
endif


set viminfo='1000,f1,<500
set linespace=0                 " No extra spaces between rows
set numberwidth=5               " Width of the line-no. column
set magic                       " Make regex a little easier to type
set winminheight=0              " Windows can be 0 line high

if has('ag')
    set grepprg=ag
endif

set report=0                    " Threshold for reporting number of lines changed.
set updatecount=0               " After typing this many characters the swap file will be written to disk.  When zero, no swap file will be created at all (see chapter on recovery |crash-recovery|).  "
set updatetime=250              " milliseconds elapsed before which swap file will be written to disk (250 ms is recommende by gitgutter plugin)

" highlight ColorColumn ctermbg=magenta
" call matchadd('ColorColumn', '\%81v', 100)
" set colorcolumn=121
" Sets the ColorColumn to a sensible color.
" highlight ColorColumn ctermbg=237 guibg=#3a3a3a
" only show the colorcolumn if the width surpasses 80 on that specific line
highlight OverLength ctermfg=0 ctermbg=3
match OverLength /\%121v/

set nojoinspaces

" When switching buffers, preserve window view.(Vim tip 1375)
if v:version >= 700
    au BufLeave * if !&diff |
                \ let b:winview = winsaveview() |
                \ endif
    au BufEnter * if exists('b:winview') && !&diff |
                \ call winrestview(b:winview) |
                \ unlet! b:winview |
                \ endif
endif


nnoremap : ;
nnoremap ; :
nnoremap Y y$

" Move across wrapped lines like regular lines
noremap 0 ^
" Go to the first non-blank character of a line
noremap ^ 0
" Just in case you need to go to the very beginning of a line

nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-h> <C-w>h
nnoremap <C-l> <C-w>l

" nnoremap <silent><Leader><C-]> <C-w><C-]><C-w>T  " open tags in new tab

inoremap <C-c> <Esc>

set guioptions-=m
set guioptions-=r
set guioptions-=T
"set guicursor+=a:blinkon0

" CTRL-U in insert mode deletes a lot.  Use CTRL-G u to first break undo,
" so that you can undo CTRL-U after inserting a line break.
" Revert with ":iunmap <C-U>".
" inoremap <C-U> <C-G>u<C-U>

" C-n and C-p now complete commands in command mode like up and down arrow
cnoremap <c-n>  <down>
cnoremap <c-p> <up>


if has("autocmd")
    " autocmd BufRead,BufNewFile *mutt-* setfiletype mail
    " autocmd BufRead,BufNewFile *mutt-* setlocal fo+=aw
    " autocmd FileType text setlocal textwidth=78
    autocmd FileType tex setlocal textwidth=120
    au BufNewFile,BufRead *.tex set list
    autocmd FileType tex setlocal keywordprg=texdoc
    " Syntax of the following languages is fussy over tabs Vs spaces
    " autocmd FileType yaml setlocal ts=2 sts=2 sw=2 expandtab
    " autocmd FileType c,cpp :set cindent
    " autocmd FileType python nnoremap <buffer> <F11> :exec '!clear;python'
    " shellescape(@%, 1)<cr>  # execute python commands
    autocmd BufEnter * silent! normal! g`"
    " autocmd BufNewFile,BufRead *.rss setfiletype xml     " Treat .rss files as XML
    " autocmd BufNewFile,BufRead *.json setfiletype json syntax=javascript
    au BufNewFile,BufRead *.py "(PEP8 indentation)
    " au BufAddr highlighted search,BufNewFile * nested tab sball "To open each buffer in its own tabpage
    autocmd FileType c,cpp,java,php,text,python,matlab,tex autocmd BufWritePre <buffer> %s/\s\+$//e
    autocmd BufWritePre .*rc %s/\s\+$//e
    au BufNewFile,BufRead *.csv set nolist
    au BufNewFile,BufRead *.py "(PEP8 indentation)
                \ set tabstop=4
                \ set softtabstop=4
                \ set shiftwidth=4
                \ set textwidth=79
                \ set expandtab
                \ set autoindent
                \ set fileformat=unix

    " Put these in an autocmd group, so that you can revert them with:   " ":augroup vimStartup | au! | augroup END"
    augroup vimStartup
        au!
        " When editing a file, always jump to the last known cursor position.
        " Don't do it when the position is invalid or when inside an event handler
        " (happens when dropping a file on gvim).
        autocmd BufReadPost *
                    \ if line("'\"") >= 1 && line("'\"") <= line("$") |
                    \   exe "normal! g`\"" |
                    \ endif
    augroup END





    augroup autoformat_settings
        " autocmd FileType bzl AutoFormatBuffer buildifier
        " autocmd FileType c,cpp,proto,javascript AutoFormatBuffer clang-format
        " autocmd FileType dart AutoFormatBuffer dartfmt
        " autocmd FileType go AutoFormatBuffer gofmt
        " autocmd FileType gn AutoFormatBuffer gn
        " autocmd FileType html,css,json AutoFormatBuffer js-beautify
        " autocmd FileType java AutoFormatBuffer google-java-format
        " autocmd FileType python AutoFormatBuffer yapf
        " Alternative: autocmd FileType python AutoFormatBuffer autopep8
    augroup END

    augroup reload_vimrc
        autocmd!
        autocmd! BufWritePost $MYVIMRC,$MYGVIMRC nested source %
        au FocusLost * :wa
    augroup END

    " au VimEnter,BufRead,BufNewFile *.jl set filetype=julia
    " au VimEnter,BufRead,BufNewFile *.idr set filetype=idris
    " au VimEnter,BufRead,BufNewFile *.lidr set filetype=lidris

    au BufWritePre * :set binary | set noeol
    au BufWritePost * :set nobinary | set eol

    augroup collumnLimit
        autocmd!
        autocmd BufEnter,WinEnter,FileType scala,java
                    \ highlight CollumnLimit ctermbg=DarkGrey guibg=DarkGrey
        let collumnLimit = 79 " feel free to customize
        let pattern =
                    \ '\%<' . (collumnLimit+1) . 'v.\%>' . collumnLimit . 'v'
        autocmd BufEnter,WinEnter,FileType scala,java
                    \ let w:m1=matchadd('CollumnLimit', pattern, -1)
    augroup END
endif

nnoremap g{ k{<Space>0
vnoremap g{ k{<Space>0
nnoremap g} j}<BS>0
vnoremap g} j}<BS>0


if (has("termguicolors"))
    set t_8f=[38;2;%lu;%lu;%lum
    set t_8b=[48;2;%lu;%lu;%lum
    set termguicolors
endif

if has('win32')
    set clipboard=unnamed " normal OS clipboard interaction
else                    " use xsel on Linux
    set clipboard+=unnamedplus
endif


set scrolloff=3        " Minimal number of screen lines to keep above and below the cursor
set sidescroll=3       " The minimal number of columns to scroll horizontally
set sidescrolloff=5    " The minimal number of screen columns to keep to the left and to the right of the cursor
set scrolljump=5       " How many lines to scroll at a time, make scrolling appears faster (i.e. when you move the cursor close to the vertical limits of display, how many more lines to reveal ?)

set tabpagemax=15      " Maximum number of tab pages to be opened by the |-p| command line argument or the ":tab all" command. |tabpage|

" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made.
" Only define it when not defined already.
" Revert with: ":delcommand DiffOrig".
if !exists(":DiffOrig")
    command DiffOrig vert new | set bt=nofile | r ++edit # | 0d_ | diffthis
                \ | wincmd p | diffthis
endif


if has('langmap') && exists('+langremap')
    " Prevent that the langmap option applies to characters that result from a
    " mapping.  If set (default), this may break plugins (but it's backward
    " compatible).
    set nolangremap
endif

:autocmd BufWritePost * if &diff | diffupdate | endif
au BufEnter,BufNew * if &diff | syntax off | else | syntax on | endif

" " Fix the difficult-to-read default setting for diff text highlighting.  The
" " bang (!) is required since we are overwriting the DiffText setting. The highlighting
" " for "Todo" also looks nice (yellow) if you don't like the "MatchParen" colors.
" highlight! link DiffText MatchParen
" highlight! link DiffText Todo


set diffopt=filler,vertical
set diffopt+=iwhite

nmap du :wincmd w<cr>:normal u<cr>:wincmd w<cr>
nnoremap Q :normal n.<CR>

" Use sane movement along wrapped lines
nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk

vnoremap y myy`y
vnoremap Y myY`y

set lazyredraw
set shortmess+=atI

" Reselect visual block after indent/outdent
vnoremap < <gv
vnoremap > >gv
xnoremap > >gv
xnoremap < <gvoremap w!! w !sudo tee > /dev/null %


" Re-hardwrap paragraph
nnoremap <leader>q gqip

set secure

set title
set titleold=

" Delete comment character when joining commented lines
if v:version > 703 || v:version == 703 && has("patch541")
    set formatoptions+=j
elseif has('nvim')
    set formatoptions+=j
endif

set formatoptions+=t "
" set formatoptions=qrno
set fo+=aw
" set formatoptions+=w
" set formatoptions+=a
" set formatoptions+=n "
" set fillchars=vert:\|,fold:+
" set fillchars=fold:+

" if has("autocmd")
"     " Treat '=' as a keyword char in latex files
"     autocmd InsertEnter *.{tex} setlocal iskeyword+==
"     autocmd InsertLeave *.{tex} setlocal iskeyword-==
" endif


"  If already loaded, we're done...
"if exists("loaded_HLNext")
"    finish
"endif
"let loaded_HLNext = 1
"
"" Preserve external compatibility options, then enable full vim compatibility...
"let s:save_cpo = &cpo
"set cpo&vim
"
""====[ INTERFACE ]=============================================
"
"if maparg('/','n') == ""
"    nnoremap  <unique>         /   :call HLNextSetTrigger()<CR>/
"endif
"if maparg('?','n') == ""
"    nnoremap  <unique>         ?   :call HLNextSetTrigger()<CR>?
"endif
"if maparg('n','n') == ""
"    nnoremap  <unique><silent> n  n:call HLNext()<CR>
"endif
"if maparg('N','n') == ""
"    nnoremap  <unique><silent> N  N:call HLNext()<CR>
"endif
"
"" Default highlighting for next match...
"highlight default HLNext ctermfg=white ctermbg=red
"
"
""====[ IMPLEMENTATION ]=======================================
"
"" Clear previous highlighting and set up new highlighting...
"function! HLNext ()
"    " Remove the previous highlighting, if any...
"    call HLNextOff()
"
"    " Add the new highlighting...
"    let target_pat = '\c\%#\%('.@/.'\)'
"    let w:HLNext_matchnum = matchadd('HLNext', target_pat)
"endfunction
"
"" Clear previous highlighting (if any)...
"function! HLNextOff ()
"    if (exists('w:HLNext_matchnum') && w:HLNext_matchnum > 0)
"        call matchdelete(w:HLNext_matchnum)
"        unlet! w:HLNext_matchnum
"    endif
"endfunction
"
"" Prepare to active next-match highlighting after cursor moves...
"function! HLNextSetTrigger ()
"    augroup HLNext
"        autocmd!
"        autocmd  CursorMoved  *  :call HLNextMovedTrigger()
"    augroup END
"endfunction
"
"" Highlight and then remove activation of next-match highlighting...
"function! HLNextMovedTrigger ()
"    augroup HLNext
"        autocmd!
"    augroup END
"    call HLNext()
"endfunction
"
"
"" Restore previous external compatibility options
"let &cpo = s:save_cpo
autocmd FileType dot setlocal commentstring=//\ %s
autocmd FileType tex setlocal textwidth=130
if executable("par")
    autocmd FileType tex setlocal formatprg=par\ -w95rjeq
    autocmd FileType txt setlocal formatprg=par\ -w95req
elseif executable("fmt")
    autocmd FileType tex setlocal formatprg=fmt -w95
    autocmd FileType txt setlocal formatprg=fmt -w95
endif
" autocmd BufReadPre *.tex setlocal textwidth=130

set isfname-={,}

if has('win32')
    set selection=inclusive
endif

" map <C-S-O> :tabnew<CR>bwipeout<CR>:vs<CR>

function! FormatprgLocal(filter)
    if !empty(v:char)
        return 1
    else
        let l:command = v:lnum.','.(v:lnum+v:count-1).'!'.a:filter
        echo l:command
        execute l:command
    endif
endfunction


nnoremap <Space> za

" Use sane regexes
nnoremap / /\v
vnoremap / /\v
nnoremap ? ?\v
vnoremap ? ?\v


nmap <silent> <leader>s :set spell!<CR>

" command! -nargs=* Wrap set wrap linebreak nolist

nnoremap & :&&<Enter>
xnoremap & :&&<Enter>

" Visual line repeat {{{2
xnoremap . :normal .<CR>
xnoremap @ :<C-u>call ExecuteMacroOverVisualRange()<CR>

function! ExecuteMacroOverVisualRange()
    echo '@'.getcmdline()
    execute ":'<,'>normal @".nr2char(getchar())
endfunction

" " for linux and windows users (using the control key)
" map <C-S-]> gt
" map <C-S-[> gT
" map <C-1> 1gt
" map <C-2> 2gt
" map <C-3> 3gt
" map <C-4> 4gt
" map <C-5> 5gt
" map <C-6> 6gt
" map <C-7> 7gt
" map <C-8> 8gt
" map <C-9> 9gt
" map <C-0> :tablast<CR>
" Automatically set current directory to browsing directory.

let g:netrw_keepdir=0
let g:netrw_list_hide='\.un\~$'
let g:netrw_banner       = 0
let g:netrw_keepdir      = 0
" let g:netrw_liststyle    = 1 " or 3
let g:netrw_sort_options = 'i'
" absolute width of netrw window
let g:netrw_winsize = -28

" tree-view
let g:netrw_liststyle = 3

" sort is affecting only: directories on the top, files below
let g:netrw_sort_sequence = '[\/]$,*'


autocmd BufEnter * if expand("%:p:h") !~ '^/tmp' | silent! lcd %:p:h | endif
nnoremap ,cd :cd %:p:h<CR>:pwd<CR>

au BufRead,BufNewFile .followup,.article,.letter,/tmp/pico*,nn.*,snd.*,/tmp/mutt* :set ft=mail
" autocmd BufEnter * :syntax sync fromstart
" let c_minlines=500
:noremap <Leader>f :filetype detect<CR>

" autocmd filetype matlab setlocal colorscheme PaperColor
" autocmd filetype matlab setlocal set background=light
" function! Zathura_md()
"     execute !zathura %:r.pdf
" endfunction

" map <leader>v Zathura_md()<CR>

" nnoremap <leader>v !make<CR>
" :nnoremap <silent> <leader>bi :!make<CR><CR>

if exists('$TMUX')
    let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
    let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
    let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
    let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
else
    let &t_SI = "\<Esc>]50;CursorShape=1\x7"
    let &t_EI = "\<Esc>]50;CursorShape=0\x7"
endif

augroup SaveCursor
    autocmd!
    autocmd BufReadPost * call setpos(".", getpos("'\""))
augroup END

" http://vim.wikia.com/wiki/Detect_window_creation_with_WinEnter
augroup vim_enter
    autocmd!
    autocmd VimEnter * autocmd vim_enter WinEnter * let w:created=1
augroup END

" disable paste mode on leaving INSERT mode
augroup insert_leave
    autocmd!
    autocmd InsertLeave * set nopaste
augroup END

augroup FileChangedAlert
    " Helps if you have to use another editor on the same file
    autocmd! FileChangedShell * echoerr "File has been changed outside of Vim."
augroup END

if has('gui_running')
    if has("gui_win32") " NT Windows
        augroup win_gui
            autocmd!
            autocmd GUIEnter * :simalt ~x
        augroup END
        set guifont=DejaVu\ Sans\ Mono\ for\ Powerline:h14
    elseif has("mac")
        set guifont=DejaVu\ Sans\ Mono\ for\ Powerline:h16
    else
        set guifont=DejaVu\ Sans\ Mono\ for\ Powerline\ 20
    endif
endif

if has('nvim')
    augroup FZFNvim
        autocmd!
        autocmd TermOpen */*fzf* tnoremap <buffer><c-k> <UP>
        autocmd TermOpen */*fzf* tnoremap <buffer><c-j> <DOWN>
    augroup END
endif

source ~/dotfiles/vim_stuff/ft_settings.vim
